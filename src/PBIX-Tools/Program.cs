using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using PowerArgs;
using Serilog;

[assembly: InternalsVisibleTo("pbix-tools.tests")]

namespace PbixTools
{
    class Program
    {
        [DllImport("kernel32.dll")]
        private static extern ErrorModes SetErrorMode(ErrorModes uMode);

        [Flags]
        [SuppressMessage("ReSharper", "InconsistentNaming")]
        private enum ErrorModes : uint
        {
            SYSTEM_DEFAULT = 0x0,
            SEM_FAILCRITICALERRORS = 0x0001,
            SEM_NOALIGNMENTFAULTEXCEPT = 0x0004,
            SEM_NOGPFAULTERRORBOX = 0x0002,
            SEM_NOOPENFILEERRORBOX = 0x8000
        }

        static Program()
        {
            // Prevent the "This program has stopped working" messages.
            SetErrorMode(ErrorModes.SEM_NOGPFAULTERRORBOX);

            Log.Logger = new LoggerConfiguration()
                .WriteTo.Console()
                .CreateLogger();
        }

        //internal static IConfigurationRoot Configuration { get; }
        internal static AppSettings AppSettings { get; } = new AppSettings();

        static int Main(string[] args)
        {

            // When invoked w/o args, print usage and exit immediately (do not trigger ArgException)
            if ((args ?? new string[0]).Length == 0)
            {
                ArgUsage.GenerateUsageFromTemplate<CmdLineActions>().WriteLine();
                return (int)ExitCode.NoArgsProvided;
            }

            var success = false;
            try
            {
                var action = Args.InvokeAction<CmdLineActions>(args); // throws ArgException

                // in Debug compilation, propagates any exceptions thrown by executing action
                // in Release compilation, a user friendly error message is displayed, and exceptions thrown are available via the HandledException property

                /* This branch only applies in Release mode, and only to parser eceptions */
                if (action.HandledException != null)
                {
                    // Standard output has been generated by PowerArgs framework already
                    Console.WriteLine();
                    Log.Logger.Verbose(action.HandledException, "PowerArgs exception");
                }

                // TODO Define and handle specific exceptions to report back to user directly (No PBI install, etc...)

                success = action.HandledException == null;
            }
            catch (ArgException ex) // this will only be hit in DEBUG complation, hence should only matter to devs
            {
                if (!Environment.UserInteractive)
                {
                    Log.Logger.Fatal(ex, "Bad user input.");
                }
                else
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.Error.WriteLine(ex.Message);
                    Console.ResetColor();

                    ArgUsage.GenerateUsageFromTemplate<CmdLineActions>().WriteLine();
                }
            }
            catch (Exception ex) /* Any other unhandled exception */
            {
                // TODO Explicitly log into crash file...
                // If CWD is not writable, put into user profile and show path...

                Log.Logger.Fatal(ex, "An unhandled exception occurred.");
            }

            if (Debugger.IsAttached && Environment.UserInteractive)
            {
                Console.Write("Press ENTER to exit...");
                Console.ReadLine();
            }

            // ExitCode:
            return success ? 0 : 1;
        }
    }

    public enum ExitCode
    {
        UnexpectedError = -2,
        NoArgsProvided = -1,
        Success = 0,
        FileNotFound = 1,
        DependenciesNotInstalled = 2,
    }

    internal static class AssemblyVersionInformation
    {
        // TODO Auto-Gen AssemblyInfo
        public const string AssemblyDescription = "pbix-tools";
        public const string AssemblyInformationalVersion = "0.0.0-alpha1";
    }

    public class AppSettings
    {
        // TODO Define AppSettings
    }

#if !DEBUG
    [ArgExceptionBehavior(ArgExceptionPolicy.StandardExceptionHandling)]  // PowerArgs will print the user friendly error message as well as the auto-generated usage documentation for the program.
#endif
    [ArgDescription(AssemblyVersionInformation.AssemblyDescription + ", " + AssemblyVersionInformation.AssemblyInformationalVersion)]
    public class CmdLineActions
    {

        private readonly IDependenciesResolver _dependenciesResolver = new DependenciesResolver(); // TODO allow to init this with a set path from config

        public CmdLineActions() : this(Program.AppSettings)
        {
        }

        public CmdLineActions(AppSettings appSettings)
        {
            if (appSettings == null) throw new ArgumentNullException(nameof(appSettings));
        }



        [HelpHook, ArgShortcut("-?"), ArgDescription("Shows this help")]
        public bool Help { get; set; }




        [ArgActionMethod, ArgDescription("Extracts the contents of a PBIX/PBIT file into a folder structure suitable for source control. By default, this will create a sub-folder in the directory of the *.pbix file with the same name without the extension.")]
        public void Extract(
            [ArgRequired, ArgExistingFile, ArgDescription("The path to an existing PBIX file")] string path
        )
        {
            var extractor = new PbixExtractAction(path, _dependenciesResolver);

            extractor.ExtractMashup();
            Console.WriteLine("Mashup extracted");

            extractor.ExtractModel();
            Console.WriteLine("Model extracted");

            extractor.ExtractReport();
            Console.WriteLine("Report extracted");

            extractor.ExtractResources();
            Console.WriteLine("Resources extracted");

            Console.WriteLine("Completed.");
        }

    }
}
